//@author: a0112066u



	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\commons\TaskData.java
	 */

	@Override
	public int compareTo(TaskData task) {
		String prior = task.getPriority();
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();

		if (this.startDateTime == null && start != null) {
			if (this.endDateTime == null) {
				return 1;
			}
			if (this.endDateTime.isBefore(end)) {
				return -1;
			}
			return 1;
		}
		if (this.startDateTime != null && start == null) {
			if (end == null) {
				return -1;
			}
			if (end.isBefore(this.startDateTime)) {
				return 1;
			}
			return -1;
		}
		if (this.startDateTime != null && start != null) {
			if (this.startDateTime.isAfter(start)) {
				return 1;
			}
			if (this.startDateTime.isBefore(start)) {
				return -1;
			}
		}
		if (this.endDateTime == null && end == null) {
			if (this.getPriority().equals(VERY_HIGH_PRI)) {
				return -1;
			}
			if (prior.equals(VERY_HIGH_PRI)) {
				return 1;
			}
			if (this.getPriority().equals(HIGH_PRI)) {
				return -1;
			}
			if (prior.equals(HIGH_PRI)) {
				return 1;
			}
			return 0;
 		}
		if (this.endDateTime == null) {
			return 1;
		}
		if (end == null) {
			return -1;
		}
		if (this.endDateTime.equals(end)) {
			if (this.getPriority().equals(VERY_HIGH_PRI)) {
				return -1;
			}
			if (prior.equals(VERY_HIGH_PRI)) {
				return 1;
			}
			if (this.getPriority().equals(HIGH_PRI)) {
				return -1;
			}
			if (prior.equals(HIGH_PRI)) {
				return 1;
			}
			return 0;
		}
		if (this.endDateTime.isAfter(end)) {
			return 1;
		}
		return -1;

	}
}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\commons\TaskData.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected void setupDatabase() {
		storer = FileStorage.getInstance();
		storer.setupDatabase(taskFilePath); // act upon changes made in storage
		storer.setupDatabase(completedTaskFilePath); // act upon changes
		storer.setupDatabase(blockedPath); // made in storage
	}

	/** This methods is to initialise all variables **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected void initialiseVariables() {
		command = null;
		task = null;
		taskList = new ArrayList<TaskData>();
		taskIdentifier = new HashMap<String, HashMap<DateInfo, TaskData>>();
		completedTaskIdentifier = new HashMap<String, TaskData>();
		actionList = new Stack<ActionEntry>();
		redoList = new Stack<ActionEntry>();
		F2DisplayedList = new ArrayList<TaskData>();
		completedTask = new ArrayList<TaskData>();
		parser = new Parser();
		searchTool = new SearchTool();
		entry = new ActionEntry(action, null);
		reminderParser = new ReminderPatternFinder();
		messageToUser = "";
	}

	/** This method is to load all data saved in the files **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected void loadData() throws IOException, ParseException {
		taskList = new ArrayList<TaskData>(storer.loadTasks(taskFilePath));
		for (TaskData t : taskList) {
			String content = t.getContent();
			if (taskIdentifier.containsKey(content)) {
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);
				map.put(new DateInfo(t.getStartDateTime(), t.getEndDateTime()),
						t);
			} else {
				taskIdentifier.put(content, new HashMap<DateInfo, TaskData>());
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);
				map.put(new DateInfo(t.getStartDateTime(), t.getEndDateTime()),
						t);
			}
		}
		completedTask = new ArrayList<TaskData>(
				storer.loadTasks(completedTaskFilePath));
		blockedList = storer.loadTasks(blockedPath);
	}

	/**
	 * this method is called by main to execute a command
	 * 
	 * @return message to user
	 */
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected String executeInputCommand(String _command) throws IOException,
			ParseException {
		if (_command == null || _command.isEmpty()) {
			_command = " ";
		}
		extractCommandandTask(_command);
		boolean isSuccessful;
		isSuccessful = executeCommand(command, task);
		String message;
		if (isSuccessful) {
			message = MSG_SUCCESSFUL + messageToUser;
		} else if (isSuspendedAction) {
			message = MSG_ASK_FOR_TIME;
		} else {
			message = MSG_ERROR + messageToUser;
		}
		messageToUser = "";
		return message;
	}

	/**
	 * this method is to extract command and task from input command using
	 * parser
	 */
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected void extractCommandandTask(String _command) {
		action = parser.getAction(_command);
		command = action.getCommand();
		task = action.getTask();
		if (isSuspendedAction) {
			command = suspendingAction.getCommand();
			Task t = suspendingAction.getTask();
			task.setContent(t.getContent());
		}
		getReminderDateTime(_command, toTaskData(task)); // get reminder
															// date/time
	}

	/** get reminder date and time from reminder parser **/
	protected void getReminderDateTime(String command, TaskData t) {
		Object obj = reminderParser.parse(command);
		if (obj == null) {
			reminderDateTime = null;
			reminderMinutes = null;
		} else if (obj instanceof LocalDateTime) {
			reminderDateTime = (LocalDateTime) obj;
		} else if (obj instanceof Integer) {
			reminderMinutes = (Integer) obj;
			if (reminderMinutes == -1) {
				reminderDateTime = LocalDateTime.MIN;
				reminderMinutes = null;
				return;
			}
			if ((t.getStartDateTime() == null) && (t.getEndDateTime() == null)) {
				reminderDateTime = null;
			} else if (t.getStartDateTime() != null) {
				reminderDateTime = t.getStartDateTime().minusMinutes(
						reminderMinutes);
			} else if (t.getEndDateTime() != null) {
				reminderDateTime = t.getEndDateTime().minusMinutes(
						reminderMinutes);
			}
		}
	}

	/**
	 * This method is to execute each specific type of command if successfulled
	 * executed, action is push to undo/redo stack
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean executeCommand(Command command, Task task)
			throws IOException, ParseException {
		boolean isSuccessful;
		switch (command) {
		case ADD:
			isSuccessful = addTask(toTaskData(task), false);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case DELETE:
			isSuccessful = deleteTask(toTaskData(task), false);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case MODIFY:
			isSuccessful = modifyTask(task, null, false);
			if (isSuccessful)
				actionList.push(entry);
			return isSuccessful;
		case UNDO:
			isSuccessful = undo();
			return isSuccessful;
		case REDO:
			isSuccessful = redo();
			return isSuccessful;
		case SEARCH:
			isSuccessful = search(task);
			return isSuccessful;
		case MARK:
			isSuccessful = mark(toTaskData(task), false);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case BLOCK:
			ArrayList<TaskData> block = new ArrayList<TaskData>();
			block.add(toTaskData(task));
			isSuccessful = block(block);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case UNBLOCK:
			ArrayList<TaskData> unblock = new ArrayList<TaskData>();
			unblock.add(toTaskData(task));
			isSuccessful = unblock(unblock);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case EXIT:
			return exit();
		default:
			return false;
		}
	}

	/** This method is for adding a task */
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean addTask(TaskData task, boolean unredo) {
		String content = task.getContent();
		if (content == null || content.isEmpty()) {
			messageToUser = MSG_EMPTY_INPUT;
			return false;
		}
		if (done && unredo) {
			// in case undo delete a completed task
			completedTask.add(task);
		} else {
			if (task.getStartDateTime() != null
					&& task.getEndDateTime() != null
					&& isClashingWithBlockedSlots(task)) {
				messageToUser = MSG_CLASHES;
				return false;
			}
			if (task.getPriority() == null) {
				// priority is set normal as default if not specified
				task.setPriority("normal");
			}
			if (task.getCategory() == null) {
				// category is set none as default if not specified
				task.setCategory("none");
			}
			if (taskIdentifier.containsKey(content)) {
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);

				TaskData t = searchTool.findExactTask(task, map);
				// this is to determine whether the task has been added
				if (t != null) { // if exist a same tasks
									// inform user
					messageToUser = MSG_EXISTING_TASK;
					return false;
				} else { // if not, add it in the map
					map.put(new DateInfo(task.getStartDateTime(), task
							.getEndDateTime()), task);
				}
			} else {
				taskIdentifier.put(content, new HashMap<DateInfo, TaskData>());
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);
				map.put(new DateInfo(task.getStartDateTime(), task
						.getEndDateTime()), task);
			}
			/** set reminder **/
			if (reminderDateTime != null) {
				task.setRemindDateTime(reminderDateTime);
				task.setReminder();
			} else {
				System.out.println("Reminder date and time is not set!");
			}
			/** **/
			taskList.add(task);
			F2DisplayedList.add(0, task);
		}
		try {
			saveData();
			saveCompletedTask();
		} catch (Exception e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return true;
	}

	/** This method determines of a task clashes with a blocked time **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected boolean isClashingWithBlockedSlots(TaskData task) {
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();
		for (TaskData _task : blockedList) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (isClash(start, end, _start, _end))
				return true;
		}
		return false;
	}

	/** This method is to delete a task described by content **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean deleteTask(TaskData task, boolean unredo) {
		String content = task.getContent();
		if (isInteger(content)) {
			return deleteIndex(Integer.parseInt(content), unredo);
		}
		if (content == null || content.isEmpty()) {
			messageToUser = MSG_NO_TASK_SPCIFIED;
			return false;
		}
		if (done) { // if delete a completed task
			if (completedTask.contains(task)) {
				completedTask.remove(task);
				Task t = toTask(task, done);
				action = new Action(Command.DELETE, t);
			} else {
				messageToUser = MSG_NO_TASK_FOUND;
				return false;
			}

		} else { // if delete an uncompleted task
			if (taskIdentifier.containsKey(content)) {
				HashMap<DateInfo, TaskData> toDeleteList = taskIdentifier
						.get(content);
				TaskData toDelete = null;
				LocalDateTime st = task.getStartDateTime();
				LocalDateTime et = task.getEndDateTime();

				toDelete = getTaskToDelete(task, unredo, toDeleteList, st, et);
				if (toDelete != null) {
					if (toDeleteList.size() == 1)
						taskIdentifier.remove(content);
					else {
						DateInfo d = new DateInfo(toDelete.getStartDateTime(),
								toDelete.getEndDateTime());
						toDeleteList.remove(d);
					}
					toDelete.clearReminder(); // to kill the background reminder
												// app
					taskList.remove(toDelete);
					if (F2DisplayedList.contains(toDelete)) {
						F2DisplayedList.remove(toDelete);
					}
					Task t = toTask(toDelete, false);
					action = new Action(Command.DELETE, t);
				} else {
					messageToUser = MSG_NO_TASK_FOUND;
					return false;
				}
			} else {
				messageToUser = MSG_NO_TASK_FOUND;
				return false;
			}
		}
		try {
			saveData();
			saveCompletedTask();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return true;
	}

	/** This method determines the task to be deleted **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected TaskData getTaskToDelete(TaskData task, boolean unredo,
			HashMap<DateInfo, TaskData> toDeleteList, LocalDateTime st,
			LocalDateTime et) {
		TaskData toDelete;
		toDelete = getTaskToMark(task, unredo, toDeleteList, st, et);
		return toDelete;
	}

	/**
	 * This method is for deleting the task specified by its index on display
	 * panel
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean deleteIndex(int index, boolean unredo) {
		ArrayList<TaskData> displayedList = getDisplayedList();
		int size = displayedList.size();
		if (index < 1 || index > size) {
			messageToUser = MSG_INDEX_OUT_OF_BOUND;
			return false;
		} else {
			TaskData task = displayedList.get(index - 1);
			return deleteTask(task, unredo);
		}
	}

	/** This method is to modify a task **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean modifyTask(Task task, Task t, boolean unredo) {
		String content;
		if (t != null) {
			content = t.getContent();
		} else {
			content = task.getContent();
		}
		if (content == null || content.isEmpty()) {
			messageToUser = MSG_NO_TASK_SPCIFIED;
			return false;
		}
		if (done) {
			messageToUser = MSG_NOT_ALLOWED_MODIFY;
			return false;
		}
		if (task.getStartDateTime() != null && task.getEndDateTime() != null
				&& isClashingWithBlockedSlots(toTaskData(task))) {
			messageToUser = MSG_CLASHES;
			return false;
		}
		if (!isInteger(content.split(" ")[0])) {
			return modifyTask(task, t, content, unredo);
		} else {
			return modifyIndex(task, content, unredo);
		}
	}

	/**
	 * This method is to modify a task specified by its content into another
	 * tasks
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean modifyTask(Task _task, Task t, String content,
			boolean unredo) {
		LocalDateTime newStartTime = _task.getStartDateTime();
		LocalDateTime newEndTime = _task.getEndDateTime();
		String newCategory = _task.getCategory();
		String newPriority = _task.getPriority();
		String newContent = _task.getContent();

		if (newContent == null || newContent.isEmpty()) {
			_task.setContent(content);
		}
		newContent = _task.getContent();
		HashMap<DateInfo, TaskData> _listTaskToEdit = new HashMap<DateInfo, TaskData>();

		if (taskIdentifier.containsKey(content)) {
			_listTaskToEdit = taskIdentifier.get(content);
		}
		LocalDateTime st = _task.getStartDateTime();
		LocalDateTime et = _task.getEndDateTime();
		TaskData toFind = new TaskData(content, null, null, null, null);
		TaskData taskToModify = null;

		// start searching the task to modify
		if (unredo) {
			st = t.getStartDateTime();
			et = t.getEndDateTime();
			DateInfo d = new DateInfo(st, et);
			taskToModify = _listTaskToEdit.get(d);
		} else {
			if (isSuspendedAction) {
				DateInfo d = new DateInfo(st, et);
				taskToModify = _listTaskToEdit.get(d);
				Task suspendingTask = suspendingAction.getTask();
				newStartTime = suspendingTask.getStartDateTime();
				newEndTime = suspendingTask.getEndDateTime();
				newCategory = suspendingTask.getCategory();
				newPriority = suspendingTask.getPriority();
				suspendingAction = null;
			}
			if (t != null) {
				st = t.getStartDateTime();
				et = t.getEndDateTime();
				toFind.setStartDateTime(st);
				toFind.setEndDateTime(et);
			}
			if (!isSuspendedAction) {
				taskToModify = searchTool.findTaskByContentandDate(toFind,
						_listTaskToEdit);
				if (taskToModify != null
						&& taskToModify.getContent().equals(
								"xxxxxxxxxxxxxxxxxxxx")) {
					suspendingAction = new Action(command, _task);
					isSuspendedAction = true;
					return false;
				}
			}
		}
		// end of searching
		isSuspendedAction = false;
		if (taskToModify != null) {
			LocalDateTime oldStartTime = taskToModify.getStartDateTime();
			LocalDateTime oldEndTime = taskToModify.getEndDateTime();
			String oldCategory = taskToModify.getCategory();
			String oldPriority = taskToModify.getPriority();
			if (t == null) {
				t = new Task();
				t.setContent(content);
			}
			boolean isExisting = checkExisting(newStartTime, newEndTime,
					newCategory, newPriority, newContent, _listTaskToEdit,
					toFind, taskToModify, oldEndTime, oldCategory, oldPriority);
			if (isExisting) {
				messageToUser = MSG_EXISTING_TASK;
				return false;
			}
			deleteTask(taskToModify, false);
			doModify(_task, t, unredo, newStartTime, newEndTime, newCategory,
					newPriority, taskToModify, oldStartTime, oldEndTime,
					oldCategory, oldPriority);
			taskToModify.setContent(newContent);
			t.setContent(newContent);
			_task.setContent(content);
			addTask(taskToModify, unredo);
			action = new Action(Command.MODIFY, _task);
			entry = new ActionEntry(action, t);
		} else {
			messageToUser = MSG_NO_TASK_FOUND;
			return false;
		}
		try {
			saveData();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return true;
	}

	/** This method does modifying the task with known information **/
	//author A0112066U
	protected void doModify(Task _task, Task t, boolean unredo,
			LocalDateTime newStartTime, LocalDateTime newEndTime,
			String newCategory, String newPriority, TaskData taskToModify,
			LocalDateTime oldStartTime, LocalDateTime oldEndTime,
			String oldCategory, String oldPriority) {
		if (newStartTime != null || unredo) {
			taskToModify.setStartDateTime(newStartTime);
			t.setStartDateTime(newStartTime);
			_task.setStartDateTime(oldStartTime);
		} else {
			t.setStartDateTime(oldStartTime);
			_task.setStartDateTime(oldStartTime);
		}
		if (newEndTime != null || unredo) {
			taskToModify.setEndDateTime(newEndTime);
			t.setEndDateTime(newEndTime);
			_task.setEndDateTime(oldEndTime);
		} else {
			t.setEndDateTime(oldEndTime);
			_task.setEndDateTime(oldEndTime);
		}
		if (newCategory != null || unredo) {
			taskToModify.setCategory(newCategory);
			t.setCategory(newCategory);
			_task.setCategory(oldCategory);
		} else {
			t.setCategory(oldCategory);
			_task.setCategory(oldCategory);
		}
		if (newPriority != null || unredo) {
			taskToModify.setPriority(newPriority);
			t.setPriority(newPriority);
			_task.setPriority(oldPriority);
		} else {
			t.setPriority(oldPriority);
			_task.setPriority(oldPriority);
		}
	}

	/** This method checks if the task after modifying exists **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean checkExisting(LocalDateTime newStartTime,
			LocalDateTime newEndTime, String newCategory, String newPriority,
			String newContent, HashMap<DateInfo, TaskData> _listTaskToEdit,
			TaskData toFind, TaskData taskToModify, LocalDateTime oldEndTime,
			String oldCategory, String oldPriority) {
		toFind.setContent(newContent);
		if (newCategory != null)
			toFind.setCategory(newCategory);
		else
			toFind.setCategory(oldCategory);
		if (newPriority != null)
			toFind.setPriority(newPriority);
		else
			toFind.setPriority(oldPriority);
		if (newStartTime != null)
			toFind.setStartDateTime(newStartTime);
		else
			toFind.setStartDateTime(oldEndTime);
		if (newEndTime != null)
			toFind.setEndDateTime(newEndTime);
		else
			toFind.setEndDateTime(oldEndTime);
		toFind = searchTool.findExactTask(toFind, _listTaskToEdit);
		boolean isExisting = toFind != null && toFind != taskToModify;
		return isExisting;
	}

	/**
	 * This method is for modifying the task specified by its index on display
	 * panel with new description
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean modifyIndex(Task task, String content, boolean unredo) {
		String[] a = content.trim().split(" ");
		int index = Integer.parseInt(a[0]);
		content = content.substring(a[0].length()).trim();
		ArrayList<TaskData> displayedList = getDisplayedList();
		int size = displayedList.size();
		if (index < 1 || index > size) {
			messageToUser = MSG_INDEX_OUT_OF_BOUND;
			return false;
		} else {
			TaskData _task = displayedList.get(index - 1);
			Task t = new Task();
			t.setContent(_task.getContent());
			t.setStartDateTime(_task.getStartDateTime());
			t.setEndDateTime(_task.getEndDateTime());
			task.setContent(content);
			return modifyTask(task, t, t.getContent(), unredo);
		}
	}

	/** This method is to mark a task as done or undone**/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean mark(TaskData _task, boolean unredo) {
		boolean isSuccessful = false;
		String content = _task.getContent();
		if (isInteger(content)) {
			return markByIndex(Integer.parseInt(content), unredo);
		}
		if (done) {
			messageToUser = MSG_NOT_ALLOWED_MARK;
			return false;
		}
		HashMap<DateInfo, TaskData> _taskToEdit = taskIdentifier.get(content);
		TaskData task = null;
		LocalDateTime st = _task.getStartDateTime();
		LocalDateTime et = _task.getEndDateTime();

		task = getTaskToMark(_task, unredo, _taskToEdit, st, et);

		if (task != null) {
			if (_taskToEdit.size() == 1)
				taskIdentifier.remove(content);
			else {
				DateInfo d = new DateInfo(task.getStartDateTime(),
						task.getEndDateTime());
				_taskToEdit.remove(d);
			}
			taskList.remove(task);
			if (F2DisplayedList.contains(task)) {
				F2DisplayedList.remove(task);
			}
			String s = task.getStartDateTime() + "" + task.getEndDateTime();

			completedTaskIdentifier.put(s, task);
			completedTask.add(task);
			Task t = toTask(task, true);
			action = new Action(command, t);
			isSuccessful = true;
		} else {
			return isSuccessful;
		}
		try {
			saveData();
			saveCompletedTask();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return isSuccessful;
	}

	/** This method is to find the task to modify **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected TaskData getTaskToMark(TaskData _task, boolean unredo,
			HashMap<DateInfo, TaskData> _taskToEdit, LocalDateTime st,
			LocalDateTime et) {
		TaskData task;
		if (unredo || st != null || et != null) {
			DateInfo d = new DateInfo(st, et);
			task = _taskToEdit.get(d);
			if (isSuspendedAction) {
				suspendingAction = null;
				isSuspendedAction = false;
			}
		} else {
			if (isSuspendedAction) {
				DateInfo d = new DateInfo(st, et);
				task = _taskToEdit.get(d);
				suspendingAction = null;
				isSuspendedAction = false;
			} else {
				task = searchTool.findTaskByContentandDate(_task, _taskToEdit);
				if (task.getContent().equals("xxxxxxxxxxxxxxxxxxxx")) {
					if (isSuspendedAction) {
						suspendingAction = null;
						isSuspendedAction = false;
					} else {
						suspendingAction = action;
						isSuspendedAction = true;
					}
					task = null;
				}
			}
		}
		return task;
	}

	/**
	 * This method is for marking a task specified by its index on display panel
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected boolean markByIndex(int index, boolean unredo) {
		ArrayList<TaskData> displayedList = getDisplayedList();
		int size = displayedList.size();
		if (index < 1 || index > size) {
			messageToUser = MSG_INDEX_OUT_OF_BOUND;
			return false;
		} else {
			TaskData task = displayedList.get(index - 1);
			return mark(task, unredo);
		}

	}

	/** This method is to block a list of slots **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected boolean block(ArrayList<TaskData> blocks) {
		ArrayList<TaskData> block = new ArrayList<TaskData>();
		for (TaskData _task : blocks) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (_start == null || _end == null) {
				messageToUser = MSG_TIME_SPECIFIED;
				return false;
			}
			block.addAll(block(_task));
		}
		blockSlot.push(block);
		storer.saveTasks(blockedPath, blockedList);
		return true;
	}

	/** This method is to unblock a list of slots **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean unblock(ArrayList<TaskData> blocks) {

		ArrayList<TaskData> unblock = new ArrayList<TaskData>();
		for (TaskData _task : blocks) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (_start == null || _end == null) {
				messageToUser = MSG_TIME_SPECIFIED;
				return false;
			}
			unblock.addAll(unblock(_task));
		}
		unblockSlot.push(unblock);
		storer.saveTasks(blockedPath, blockedList);
		return true;
	}

	/** This method is to block a slot **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected ArrayList<TaskData> block(TaskData slot) {

		LocalDateTime st = slot.getStartDateTime();
		LocalDateTime et = slot.getEndDateTime();
		LocalDateTime start = slot.getStartDateTime();
		LocalDateTime end = slot.getEndDateTime();
		slot.setContent("Blocked slot");
		blockedList.add(slot);
		ArrayList<TaskData> copy = new ArrayList<TaskData>(blockedList);
		for (TaskData _task : copy) {
			if (_task == slot)
				continue;
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (isClash(start, end, _start, _end)
					|| isSequential(start, end, _start, _end)) {
				_start = chooseStart(start, _start);
				_end = chooseEnd(end, _end);
				slot.setStartDateTime(_start);
				slot.setEndDateTime(_end);
				blockedList.remove(_task);
			}
			start = slot.getStartDateTime();
			end = slot.getEndDateTime();
		}
		ArrayList<TaskData> block = new ArrayList<TaskData>();
		block.add(new TaskData("Blocked slot", null, null, st, et));
		return block;
	}

	/** This method is to unblock a slot **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected ArrayList<TaskData> unblock(TaskData task) {
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();
		ArrayList<TaskData> copy = new ArrayList<TaskData>(blockedList);
		ArrayList<TaskData> unblocked = new ArrayList<TaskData>();
		for (TaskData _task : copy) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (isClash(start, end, _start, _end)) {
				if ((start.isBefore(_start) || start.equals(_start))
						&& (end.isAfter(_end) || end.equals(_end))) {
					blockedList.remove(_task);
					unblocked.add(new TaskData(null, null, null, _start, _end));
					continue;
				}
				if (_start.isBefore(start) && _end.isAfter(end)) {
					_task.setEndDateTime(start);
					blockedList.remove(_task);
					_task.setEndDateTime(start);
					TaskData t = new TaskData();
					t.setStartDateTime(end);
					t.setEndDateTime(_end);
					t.setContent("Blocked slot");
					_task.setContent("Blocked slot");
					blockedList.add(0, t);
					blockedList.add(0, _task);
					unblocked.add(new TaskData(null, null, null, start, end));
					continue;
				}
				if ((start.isBefore(_start) || start.equals(_start)) && end.isBefore(_end)) {
					blockedList.remove(_task);
					_task.setStartDateTime(end);
					blockedList.add(_task);
					unblocked.add(new TaskData(null, null, null, _start, end));
					continue;
				}
				if (_start.isBefore(start) && (_end.isBefore(end) || end.equals(_end))) {
					blockedList.remove(_task);
					_task.setEndDateTime(start);
					blockedList.add(_task);
					unblocked.add(new TaskData(null, null, null, start, _end));
					continue;
				}
			}
		}
		return unblocked;
	}

	protected LocalDateTime chooseStart(LocalDateTime start1, LocalDateTime start2) {
		return (start1.isBefore(start2)) ? start1 : start2;
	}

	protected LocalDateTime chooseEnd(LocalDateTime end1, LocalDateTime end2) {
		return (end1.isAfter(end2)) ? end1 : end2;
	}

	/** This method checks if two periods of time clash with each other **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected boolean isClash(LocalDateTime start1, LocalDateTime end1,
			LocalDateTime start2, LocalDateTime end2) {
		if (start1.isEqual(start2) || end1.isEqual(end2))
			return true;
		if (start1.isAfter(start2) && start1.isBefore(end2)
				|| start2.isAfter(start1) && start2.isBefore(end1))
			return true;
		if (start1.isAfter(start2) && end1.isBefore(end2)
				|| start2.isAfter(start1) && end2.isBefore(end1))
			return true;
		return false;
	}

	/** This method checks if two periods of time are sequential **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected boolean isSequential(LocalDateTime start1, LocalDateTime end1,
			LocalDateTime start2, LocalDateTime end2) {
		return start1.isEqual(end2) || start2.isEqual(end1);
	}

	/** This method is for redoing an action **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean redo() throws IOException, ParseException {
		if (redoList.isEmpty()) {
			messageToUser = MSG_CANNOT_REDO_ANYMORE;
			return false;
		}
		ActionEntry ae = redoList.pop();
		Action done = ae.getAction();
		Task t = ae.getTask();

		actionList.push(ae);
		Command command = done.getCommand();
		Task task = done.getTask();

		TaskData _task = toTaskData(task);
		switch (command) {
		case ADD:
			if (task.isDone()) {
				this.done = true;
			}
			return addTask(_task, true);
		case DELETE:
			if (task.isDone()) {
				this.done = true;
			}
			return deleteTask(_task, true);
		case MODIFY:
			return modifyTask(task, t, true);
		case MARK:
			return mark(_task, true);
		case BLOCK:
			ArrayList<TaskData> blockList = unblockSlot.pop();
			blockSlot.push(blockList);
			return block(blockList);
		case UNBLOCK:
			ArrayList<TaskData> unblockList = blockSlot.pop();
			unblockSlot.push(unblockList);
			return unblock(unblockList);
		default:
			return false;
		}
	}

	/** This method is for undoing an action **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean undo() {
		boolean isSuccessful = false;
		if (actionList.isEmpty()) {
			messageToUser = MSG_CANNOT_UNDO;
			return isSuccessful;
		}
		ActionEntry x = actionList.pop();
		Action done = x.getAction();
		Command command = done.getCommand();
		switch (command) {
		case ADD:
			isSuccessful = undoAdd(done);
			break;
		case DELETE:
			isSuccessful = undoDelete(done);
			break;
		case MODIFY:
			isSuccessful = undoModify(done, x.getTask());
			break;
		case MARK:
			isSuccessful = undoMark(done);
			break;
		case BLOCK:
			isSuccessful = undoBlock(done);
			break;
		case UNBLOCK:
			isSuccessful = undoUnblock(done);
			break;
		default:
			isSuccessful = false;
			break;
		}
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean undoDelete(Action done) {
		if (done.getTask().isDone()) {
			this.done = true;
		}
		boolean isSuccessful = addTask(toTaskData(done.getTask()), true);
		if (isSuccessful)
			redoList.push(new ActionEntry(done, null));
		else
			actionList.push(new ActionEntry(done, null));
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean undoAdd(Action done) {
		if (done.getTask().isDone()) {
			this.done = true;
		}
		boolean isSuccessful = deleteTask(toTaskData(done.getTask()), true);
		if (isSuccessful)
			redoList.push(new ActionEntry(done, null));
		else
			actionList.push(new ActionEntry(done, null));
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean undoModify(Action done, Task t) {
		boolean isSuccessful = modifyTask(done.getTask(), t, true);
		if (isSuccessful)
			redoList.push(entry);
		else
			actionList.push(entry);
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean undoMark(Action done) {
		Task task = done.getTask();
		boolean isSuccessful = false;
		String s = task.getStartDateTime() + "" + task.getEndDateTime();
		TaskData _task = completedTaskIdentifier.get(s);
		try {
			completedTask.remove(_task);
			isSuccessful = addTask(_task, true);
			saveCompletedTask();
		} catch (IOException e) {
			isSuccessful = false;
		}
		if (isSuccessful) {
			redoList.push(new ActionEntry(done, null));
		} else {
			actionList.push(new ActionEntry(done, null));
		}
		return isSuccessful;
	}

	protected boolean undoBlock(Action done) {
		boolean isSuccessful = false;
		ArrayList<TaskData> blockList = blockSlot.pop();
		isSuccessful = unblock(blockList);
		unblockSlot.push(blockList);
		if (isSuccessful) {
			redoList.push(new ActionEntry(done, null));
		} else {
			actionList.push(new ActionEntry(done, null));
		}
		return isSuccessful;
	}

	protected boolean undoUnblock(Action done) {
		boolean isSuccessful = false;
		ArrayList<TaskData> blockList = unblockSlot.pop();
		isSuccessful = block(blockList);
		blockSlot.push(blockList);
		if (isSuccessful) {
			redoList.push(new ActionEntry(done, null));
		} else {
			actionList.push(new ActionEntry(done, null));
		}
		return isSuccessful;
	}

	/**
	 * This method is to search for a task or a block slot, return in
	 * searchResult
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected boolean search(Task task) throws IOException, ParseException {
		searchResult = new ArrayList<TaskData>();
		String content = task.getContent();
		if (content != null
				&& !content.isEmpty()
				&& (content.startsWith("block") || content
						.startsWith("blocked"))) {
			searchResult = blockedList;
		} else {
			if (task.isDone() == null || !task.isDone()) {
				searchResult = searchTool.search(taskList, task);
				done = false;
			} else {
				searchResult = searchTool.search(completedTask, task);
				done = true;
			}
		}
		if (searchResult != null) {
			return true;
		}

		overdueRow = 0;
		return false;
	}

	/** This method is to exit, data is saved and jframe is minimised to tray **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean exit() {
		// store when exit
		try {
			saveData();
			saveCompletedTask();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
		}
		return true;
		// System.exit(0);
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected void saveData() throws IOException {
		storer.saveTasks(taskFilePath, taskList);
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected void saveCompletedTask() throws IOException {
		storer.saveTasks(completedTaskFilePath, completedTask);
	}

	/** This method returns tasks to come **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected ArrayList<TaskData> getTaskToCome() {
		LocalDateTime now = LocalDateTime.now();
		int dateToday = now.getDayOfMonth();
		int monthToday = now.getMonthValue();
		int yearToday = now.getYear();
		LocalDateTime today = LocalDateTime.of(yearToday, monthToday,
				dateToday, 0, 0, 0).minusSeconds(1);
		LocalDateTime tomorrow = today.plusSeconds(172801);
		today = now;
		ArrayList<TaskData> taskToCome = new ArrayList<TaskData>();
		for (TaskData _task : taskList) {
			LocalDateTime st = _task.getStartDateTime();
			LocalDateTime et = _task.getEndDateTime();
			if (st != null && st.isAfter(today) && st.isBefore(tomorrow)) {
				taskToCome.add(_task);
			} else if (et != null && et.isAfter(today) && et.isBefore(tomorrow)) {
				taskToCome.add(_task);
			} else if (st != null && et != null
					&& isClash(st, et, today, tomorrow)) {
				taskToCome.add(_task);
			}
		}
		return taskToCome;
	}

	/** This methods answers UI, checks if a date has task **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected boolean hasTask(String date) throws IOException, ParseException {
		Task testTask = parser.getAction(date).getTask();
		LocalDateTime time = testTask.getStartDateTime();
		int dayOfMonth = time.getDayOfMonth();
		int month = time.getMonthValue();
		int year = time.getYear();
		LocalDateTime startTime = LocalDateTime.of(year, month, dayOfMonth, 0,
				0, 0).minusSeconds(1);
		LocalDateTime endTime = LocalDateTime.of(year, month, dayOfMonth, 23,
				59, 59).plusSeconds(1);
		ArrayList<TaskData> task = new ArrayList<TaskData>();
		for (TaskData _task : taskList) {
			LocalDateTime st = _task.getStartDateTime();
			LocalDateTime et = _task.getEndDateTime();
			if (st != null && st.isAfter(startTime) && st.isBefore(endTime)) {
				task.add(_task);
			} else if (et != null && et.isAfter(startTime)
					&& et.isBefore(endTime)) {
				task.add(_task);
			} else if (st != null && et != null
					&& isClash(st, et, startTime, endTime)) {
				task.add(_task);
			}
		}
		return !task.isEmpty();
	}

	/** This method returns overdue task to UI **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected ArrayList<TaskData> getOverdue() {
		ArrayList<TaskData> overdue = new ArrayList<TaskData>();
		LocalDateTime now = LocalDateTime.now();
		Collections.sort(taskList);
		for (TaskData _task : taskList) {
			LocalDateTime endTime = _task.getEndDateTime();
			if (endTime != null && endTime.isBefore(now)) {
				overdue.add(_task);
			}
		}
		return overdue;
	}

	/** This methods return all categories to UI **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected String getCategory() {
		ArrayList<String> category = new ArrayList<String>();
		for (TaskData _task : taskList) {
			String cat = _task.getCategory();
			if (cat != null && !category.contains(cat))
				category.add(cat);
		}
		String res = "";
		for (String cat : category) {
			res += cat + "\n";
		}
		return res;
	}

	/** This methods return data of recently added tasks to UI **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected String getData(String s) throws IOException, ParseException {
		currentDisplayList = 2;
		return dataToShow();
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected String dataToShow() throws IOException, ParseException {
		return showToUser(F2DisplayedList);
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected String showToUser(ArrayList<TaskData> taskToShow) {
		String text = "";
		SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm");
		SimpleDateFormat f = new SimpleDateFormat("EEE, d MMM yyyy HH:mm");
		int i = 1;
		for (TaskData t : taskToShow) {
			text += i + ": ";
			text += t.getContent();
			if (t.getPriority() != null)
				text += "\n " + t.getPriority() + " priority ";
			if (t.getCategory() != null)
				text += "\n #" + t.getCategory() + " ";
			if (t.getStartDateTime() != null) {
				Date d;
				try {
					d = formater.parse(t.getStartDateTime() + "");
					String s = f.format(d);
					text += "\n From: " + s;
				} catch (java.text.ParseException e) {
				}
			}
			if (t.getEndDateTime() != null) {
				Date d;
				try {
					d = formater.parse(t.getEndDateTime() + "");
					String s = f.format(d);
					text += "\n To : " + s;
				} catch (java.text.ParseException e) {
				}
			}
			text += "\n";
			i++;
		}
		return text;
	}

	/* clear all data */
	//author A0112066U
	protected void clear() throws IOException {
		taskList.clear();
		completedTask.clear();
		blockedList.clear();
		saveData();
		saveCompletedTask();
		storer.saveTasks(blockedPath, blockedList);
	}

	/** This method translates a Task to TaskData for storage **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected TaskData toTaskData(Task task) {
		String content = task.getContent();
		LocalDateTime startTime = task.getStartDateTime();
		LocalDateTime endTime = task.getEndDateTime();
		String category = task.getCategory();
		String priority = task.getPriority();
		return new TaskData(content, category, priority, startTime, endTime);
	}

	/** This method translates a TaskData to Task **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected Task toTask(TaskData task, boolean done) {
		Task t = new Task();
		t.setContent(task.getContent());
		t.setCategory(task.getCategory());
		t.setStartDateTime(task.getStartDateTime());
		t.setEndDateTime(task.getEndDateTime());
		t.setPriority(task.getPriority());
		t.setDone(done);
		return t;
	}

	/** This method is to check whether a string provided is an integer **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected static boolean isInteger(String index) {
		try {
			Integer.parseInt(index);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	/** This method returns to UI the list of tasks it requires **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */


	protected ArrayList<DisplayedEntry> getRequiredTask(String userCommand) {
		Command cmd = null;
		if (userCommand != null && !userCommand.isEmpty()) {
			cmd = parser.getAction(userCommand).getCommand();
		}
		if (cmd != null && cmd.equals(Command.SEARCH)) {

			F3DisplayedList = new ArrayList<TaskData>(searchResult);
			overdueRow = 0;
		}
		if (cmd == null || cmd.equals("") || cmd.equals(Command.ADD)
				|| cmd.equals(Command.DELETE) || cmd.equals(Command.MODIFY)
				|| cmd.equals(Command.MARK) || cmd.equals(Command.UNDO)
				|| cmd.equals(Command.REDO)) {
			F3DisplayedList = new ArrayList<TaskData>();
			ArrayList<TaskData> overdue = getOverdue();
			overdueRow = overdue.size();
			ArrayList<TaskData> tasksToCome = getTaskToCome();
			F3DisplayedList.addAll(overdue);
			F3DisplayedList.addAll(tasksToCome);
			for (TaskData t : taskList) {
				if (!overdue.contains(t) && !tasksToCome.contains(t))
					F3DisplayedList.add(t);
			}
			done = false;
		}
		currentDisplayList = 3;
		ArrayList<DisplayedEntry> tobeShown = new ArrayList<DisplayedEntry>();
		if (F3DisplayedList != null) {
			for (TaskData t : F3DisplayedList) {
				tobeShown.add(toDisplayedEntry(t));
			}
		}
		return tobeShown;
	}

	protected int getOverdueRow() {
		return overdueRow;
	}

	protected String getBlock() {
		String result = "";
		for (TaskData block : blockedList) {
			DisplayedEntry b = new DisplayedEntry(block);
			try {
				result += b.getStartDateTime() + " - " + b.getEndDateTime();
				result += "\n";
			} catch (java.text.ParseException e) {
			}
		}
		return result;
	}
	/** This method is to determined what list of tasks is being displayed **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected ArrayList<TaskData> getDisplayedList() {
		if (currentDisplayList == 2) {
			return F2DisplayedList;
		} else if (currentDisplayList == 3) {
			return F3DisplayedList;
		}
		return null;
	}

	/**
	 * This method translates a TaskData to a DisplayedEntry for displaying in
	 * UI
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java
	 */

	protected DisplayedEntry toDisplayedEntry(TaskData task) {
		return new DisplayedEntry(task);
	}
}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\CopyLogic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\DisplayedEntry.java
	 */

 */
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.Date;

import reminder.Reminder;
import commons.TaskData;

public class DisplayedEntry {
	private String content;
	private String category;
	private String priority;
	private LocalDateTime startDateTime;
	private LocalDateTime endDateTime;
	private Reminder reminder;
	private LocalDateTime remindDateTime;

	public DisplayedEntry(TaskData t) {
		this.setContent(t.getContent());
		this.setCategory(t.getCategory());
		this.setPriority(t.getPriority());
		this.setStartDateTime(t.getStartDateTime());
		this.setEndDateTime(t.getEndDateTime());
		this.remindDateTime = t.getRemindDateTime();
		this.reminder = t.getReminder();
	}

	public String getContent() {
		return content;
	}

	public String getCategory() {
		return category;
	}

	public String getPriority() {
		return priority;
	}

	public String getStartDateTime() throws ParseException {
		SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm");
		SimpleDateFormat f = new SimpleDateFormat("d MMM yyyy HH:mm");

		Date d = formater.parse(startDateTime + "");
		return f.format(d);
	}

	public String getEndDateTime() throws ParseException {
		SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm");
		SimpleDateFormat f = new SimpleDateFormat("d MMM yyyy HH:mm");

		Date d = formater.parse(endDateTime + "");
		return f.format(d);
	}
	
	public LocalDateTime getRemindDateTime() {
		return remindDateTime;
	}
	
	public Reminder getReminder() {
		return reminder;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public void setCategory(String category) {
		this.category = category;
	}

	public void setPriority(String priority) {
		this.priority = priority;
	}

	public void setStartDateTime(LocalDateTime startDateTime) {
		this.startDateTime = startDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}
}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\DisplayedEntry.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private void setupDatabase() {
		storer = FileStorage.getInstance();
		storer.setupDatabase(taskFilePath); // act upon changes made in storage
		storer.setupDatabase(completedTaskFilePath); // act upon changes
		storer.setupDatabase(blockedPath); // made in storage
	}

	/** This methods is to initialise all variables **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private void initialiseVariables() {
		command = null;
		task = null;
		taskList = new ArrayList<TaskData>();
		taskIdentifier = new HashMap<String, HashMap<DateInfo, TaskData>>();
		completedTaskIdentifier = new HashMap<String, TaskData>();
		actionList = new Stack<ActionEntry>();
		redoList = new Stack<ActionEntry>();
		F2DisplayedList = new ArrayList<TaskData>();
		completedTask = new ArrayList<TaskData>();
		parser = new Parser();
		searchTool = new SearchTool();
		entry = new ActionEntry(action, null);
		reminderParser = new ReminderPatternFinder();
		messageToUser = "";
	}

	/** This method is to load all data saved in the files **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private void loadData() throws IOException, ParseException {
		taskList = new ArrayList<TaskData>(storer.loadTasks(taskFilePath));
		for (TaskData t : taskList) {
			String content = t.getContent();
			if (taskIdentifier.containsKey(content)) {
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);
				map.put(new DateInfo(t.getStartDateTime(), t.getEndDateTime()),
						t);
			} else {
				taskIdentifier.put(content, new HashMap<DateInfo, TaskData>());
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);
				map.put(new DateInfo(t.getStartDateTime(), t.getEndDateTime()),
						t);
			}
		}
		completedTask = new ArrayList<TaskData>(
				storer.loadTasks(completedTaskFilePath));
		blockedList = storer.loadTasks(blockedPath);
	}

	/**
	 * this method is called by main to execute a command
	 * 
	 * @return message to user
	 */
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	public String executeInputCommand(String _command) throws IOException,
			ParseException {
		if (_command == null || _command.isEmpty()) {
			_command = " ";
		}
		extractCommandandTask(_command);
		boolean isSuccessful;
		isSuccessful = executeCommand(command, task);
		String message;
		if (isSuccessful) {
			message = MSG_SUCCESSFUL + messageToUser;
		} else if (isSuspendedAction) {
			message = MSG_ASK_FOR_TIME;
		} else {
			message = MSG_ERROR + messageToUser;
		}
		messageToUser = "";
		return message;
	}

	/**
	 * this method is to extract command and task from input command using
	 * parser
	 */
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private void extractCommandandTask(String _command) {
		action = parser.getAction(_command);
		command = action.getCommand();
		task = action.getTask();
		if (isSuspendedAction) {
			command = suspendingAction.getCommand();
			Task t = suspendingAction.getTask();
			task.setContent(t.getContent());
		}
		getReminderDateTime(_command, toTaskData(task)); // get reminder
															// date/time
	}

	/** get reminder date and time from reminder parser **/
	private void getReminderDateTime(String command, TaskData t) {
		Object obj = reminderParser.parse(command);
		if (obj == null) {
			reminderDateTime = null;
			reminderMinutes = null;
		} else if (obj instanceof LocalDateTime) {
			reminderDateTime = (LocalDateTime) obj;
		} else if (obj instanceof Integer) {
			reminderMinutes = (Integer) obj;
			if (reminderMinutes == -1) {
				reminderDateTime = LocalDateTime.MIN;
				reminderMinutes = null;
				return;
			}
			if ((t.getStartDateTime() == null) && (t.getEndDateTime() == null)) {
				reminderDateTime = null;
			} else if (t.getStartDateTime() != null) {
				reminderDateTime = t.getStartDateTime().minusMinutes(
						reminderMinutes);
			} else if (t.getEndDateTime() != null) {
				reminderDateTime = t.getEndDateTime().minusMinutes(
						reminderMinutes);
			}
		}
	}

	/**
	 * This method is to execute each specific type of command if successfulled
	 * executed, action is push to undo/redo stack
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean executeCommand(Command command, Task task)
			throws IOException, ParseException {
		boolean isSuccessful;
		switch (command) {
		case ADD:
			isSuccessful = addTask(toTaskData(task), false);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case DELETE:
			isSuccessful = deleteTask(toTaskData(task), false);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case MODIFY:
			isSuccessful = modifyTask(task, null, false);
			if (isSuccessful)
				actionList.push(entry);
			return isSuccessful;
		case UNDO:
			isSuccessful = undo();
			return isSuccessful;
		case REDO:
			isSuccessful = redo();
			return isSuccessful;
		case SEARCH:
			isSuccessful = search(task);
			return isSuccessful;
		case MARK:
			isSuccessful = mark(toTaskData(task), false);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case BLOCK:
			ArrayList<TaskData> block = new ArrayList<TaskData>();
			block.add(toTaskData(task));
			isSuccessful = block(block);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case UNBLOCK:
			ArrayList<TaskData> unblock = new ArrayList<TaskData>();
			unblock.add(toTaskData(task));
			isSuccessful = unblock(unblock);
			if (isSuccessful)
				actionList.push(new ActionEntry(action, null));
			return isSuccessful;
		case EXIT:
			return exit();
		default:
			return false;
		}
	}

	/** This method is for adding a task */
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean addTask(TaskData task, boolean unredo) {
		String content = task.getContent();
		if (content == null || content.isEmpty()) {
			messageToUser = MSG_EMPTY_INPUT;
			return false;
		}
		if (done && unredo) {
			// in case undo delete a completed task
			completedTask.add(task);
		} else {
			if (task.getStartDateTime() != null
					&& task.getEndDateTime() != null
					&& isClashingWithBlockedSlots(task)) {
				messageToUser = MSG_CLASHES;
				return false;
			}
			if (task.getPriority() == null) {
				// priority is set normal as default if not specified
				task.setPriority("normal");
			}
			if (task.getCategory() == null) {
				// category is set none as default if not specified
				task.setCategory("none");
			}
			if (taskIdentifier.containsKey(content)) {
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);

				TaskData t = searchTool.findExactTask(task, map);
				// this is to determine whether the task has been added
				if (t != null) { // if exist a same tasks
									// inform user
					messageToUser = MSG_EXISTING_TASK;
					return false;
				} else { // if not, add it in the map
					map.put(new DateInfo(task.getStartDateTime(), task
							.getEndDateTime()), task);
				}
			} else {
				taskIdentifier.put(content, new HashMap<DateInfo, TaskData>());
				HashMap<DateInfo, TaskData> map = taskIdentifier.get(content);
				map.put(new DateInfo(task.getStartDateTime(), task
						.getEndDateTime()), task);
			}
			/** set reminder **/
			if (reminderDateTime != null) {
				task.setRemindDateTime(reminderDateTime);
				task.setReminder();
			} else {
				System.out.println("Reminder date and time is not set!");
			}
			/** **/
			taskList.add(task);
			F2DisplayedList.add(0, task);
		}
		try {
			saveData();
			saveCompletedTask();
		} catch (Exception e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return true;
	}

	/** This method determines of a task clashes with a blocked time **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	private boolean isClashingWithBlockedSlots(TaskData task) {
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();
		for (TaskData _task : blockedList) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (isClash(start, end, _start, _end))
				return true;
		}
		return false;
	}

	/** This method is to delete a task described by content **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean deleteTask(TaskData task, boolean unredo) {
		String content = task.getContent();
		if (isInteger(content)) {
			return deleteIndex(Integer.parseInt(content), unredo);
		}
		if (content == null || content.isEmpty()) {
			messageToUser = MSG_NO_TASK_SPCIFIED;
			return false;
		}
		if (done) { // if delete a completed task
			if (completedTask.contains(task)) {
				completedTask.remove(task);
				Task t = toTask(task, done);
				action = new Action(Command.DELETE, t);
			} else {
				messageToUser = MSG_NO_TASK_FOUND;
				return false;
			}

		} else { // if delete an uncompleted task
			if (taskIdentifier.containsKey(content)) {
				HashMap<DateInfo, TaskData> toDeleteList = taskIdentifier
						.get(content);
				TaskData toDelete = null;
				LocalDateTime st = task.getStartDateTime();
				LocalDateTime et = task.getEndDateTime();

				toDelete = getTaskToDelete(task, unredo, toDeleteList, st, et);
				if (toDelete != null) {
					if (toDeleteList.size() == 1)
						taskIdentifier.remove(content);
					else {
						DateInfo d = new DateInfo(toDelete.getStartDateTime(),
								toDelete.getEndDateTime());
						toDeleteList.remove(d);
					}
					toDelete.clearReminder(); // to kill the background reminder
												// app
					taskList.remove(toDelete);
					if (F2DisplayedList.contains(toDelete)) {
						F2DisplayedList.remove(toDelete);
					}
					Task t = toTask(toDelete, false);
					action = new Action(Command.DELETE, t);
				} else {
					messageToUser = MSG_NO_TASK_FOUND;
					return false;
				}
			} else {
				messageToUser = MSG_NO_TASK_FOUND;
				return false;
			}
		}
		try {
			saveData();
			saveCompletedTask();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return true;
	}

	/** This method determines the task to be deleted **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private TaskData getTaskToDelete(TaskData task, boolean unredo,
			HashMap<DateInfo, TaskData> toDeleteList, LocalDateTime st,
			LocalDateTime et) {
		TaskData toDelete;
		toDelete = getTaskToMark(task, unredo, toDeleteList, st, et);
		return toDelete;
	}

	/**
	 * This method is for deleting the task specified by its index on display
	 * panel
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean deleteIndex(int index, boolean unredo) {
		ArrayList<TaskData> displayedList = getDisplayedList();
		int size = displayedList.size();
		if (index < 1 || index > size) {
			messageToUser = MSG_INDEX_OUT_OF_BOUND;
			return false;
		} else {
			TaskData task = displayedList.get(index - 1);
			return deleteTask(task, unredo);
		}
	}

	/** This method is to modify a task **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean modifyTask(Task task, Task t, boolean unredo) {
		String content;
		if (t != null) {
			content = t.getContent();
		} else {
			content = task.getContent();
		}
		if (content == null || content.isEmpty()) {
			messageToUser = MSG_NO_TASK_SPCIFIED;
			return false;
		}
		if (done) {
			messageToUser = MSG_NOT_ALLOWED_MODIFY;
			return false;
		}
		if (task.getStartDateTime() != null && task.getEndDateTime() != null
				&& isClashingWithBlockedSlots(toTaskData(task))) {
			messageToUser = MSG_CLASHES;
			return false;
		}
		if (!isInteger(content.split(" ")[0])) {
			return modifyTask(task, t, content, unredo);
		} else {
			return modifyIndex(task, content, unredo);
		}
	}

	/**
	 * This method is to modify a task specified by its content into another
	 * tasks
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean modifyTask(Task _task, Task t, String content,
			boolean unredo) {
		LocalDateTime newStartTime = _task.getStartDateTime();
		LocalDateTime newEndTime = _task.getEndDateTime();
		String newCategory = _task.getCategory();
		String newPriority = _task.getPriority();
		String newContent = _task.getContent();

		if (newContent == null || newContent.isEmpty()) {
			_task.setContent(content);
		}
		newContent = _task.getContent();
		HashMap<DateInfo, TaskData> _listTaskToEdit = new HashMap<DateInfo, TaskData>();

		if (taskIdentifier.containsKey(content)) {
			_listTaskToEdit = taskIdentifier.get(content);
		}
		LocalDateTime st = _task.getStartDateTime();
		LocalDateTime et = _task.getEndDateTime();
		TaskData toFind = new TaskData(content, null, null, null, null);
		TaskData taskToModify = null;

		// start searching the task to modify
		if (unredo) {
			st = t.getStartDateTime();
			et = t.getEndDateTime();
			DateInfo d = new DateInfo(st, et);
			taskToModify = _listTaskToEdit.get(d);
		} else {
			if (isSuspendedAction) {
				DateInfo d = new DateInfo(st, et);
				taskToModify = _listTaskToEdit.get(d);
				Task suspendingTask = suspendingAction.getTask();
				newStartTime = suspendingTask.getStartDateTime();
				newEndTime = suspendingTask.getEndDateTime();
				newCategory = suspendingTask.getCategory();
				newPriority = suspendingTask.getPriority();
				suspendingAction = null;
			}
			if (t != null) {
				st = t.getStartDateTime();
				et = t.getEndDateTime();
				toFind.setStartDateTime(st);
				toFind.setEndDateTime(et);
			}
			if (!isSuspendedAction) {
				taskToModify = searchTool.findTaskByContentandDate(toFind,
						_listTaskToEdit);
				if (taskToModify != null
						&& taskToModify.getContent().equals(
								"xxxxxxxxxxxxxxxxxxxx")) {
					suspendingAction = new Action(command, _task);
					isSuspendedAction = true;
					return false;
				}
			}
		}
		// end of searching
		isSuspendedAction = false;
		if (taskToModify != null) {
			LocalDateTime oldStartTime = taskToModify.getStartDateTime();
			LocalDateTime oldEndTime = taskToModify.getEndDateTime();
			String oldCategory = taskToModify.getCategory();
			String oldPriority = taskToModify.getPriority();
			if (t == null) {
				t = new Task();
				t.setContent(content);
			}
			boolean isExisting = checkExisting(newStartTime, newEndTime,
					newCategory, newPriority, newContent, _listTaskToEdit,
					toFind, taskToModify, oldEndTime, oldCategory, oldPriority);
			if (isExisting) {
				messageToUser = MSG_EXISTING_TASK;
				return false;
			}
			deleteTask(taskToModify, false);
			doModify(_task, t, unredo, newStartTime, newEndTime, newCategory,
					newPriority, taskToModify, oldStartTime, oldEndTime,
					oldCategory, oldPriority);
			taskToModify.setContent(newContent);
			t.setContent(newContent);
			_task.setContent(content);
			addTask(taskToModify, unredo);
			action = new Action(Command.MODIFY, _task);
			entry = new ActionEntry(action, t);
		} else {
			messageToUser = MSG_NO_TASK_FOUND;
			return false;
		}
		try {
			saveData();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return true;
	}

	/** This method does modifying the task with known information **/
	//author A0112066U
	private void doModify(Task _task, Task t, boolean unredo,
			LocalDateTime newStartTime, LocalDateTime newEndTime,
			String newCategory, String newPriority, TaskData taskToModify,
			LocalDateTime oldStartTime, LocalDateTime oldEndTime,
			String oldCategory, String oldPriority) {
		if (newStartTime != null || unredo) {
			taskToModify.setStartDateTime(newStartTime);
			t.setStartDateTime(newStartTime);
			_task.setStartDateTime(oldStartTime);
		} else {
			t.setStartDateTime(oldStartTime);
			_task.setStartDateTime(oldStartTime);
		}
		if (newEndTime != null || unredo) {
			taskToModify.setEndDateTime(newEndTime);
			t.setEndDateTime(newEndTime);
			_task.setEndDateTime(oldEndTime);
		} else {
			t.setEndDateTime(oldEndTime);
			_task.setEndDateTime(oldEndTime);
		}
		if (newCategory != null || unredo) {
			taskToModify.setCategory(newCategory);
			t.setCategory(newCategory);
			_task.setCategory(oldCategory);
		} else {
			t.setCategory(oldCategory);
			_task.setCategory(oldCategory);
		}
		if (newPriority != null || unredo) {
			taskToModify.setPriority(newPriority);
			t.setPriority(newPriority);
			_task.setPriority(oldPriority);
		} else {
			t.setPriority(oldPriority);
			_task.setPriority(oldPriority);
		}
	}

	/** This method checks if the task after modifying exists **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean checkExisting(LocalDateTime newStartTime,
			LocalDateTime newEndTime, String newCategory, String newPriority,
			String newContent, HashMap<DateInfo, TaskData> _listTaskToEdit,
			TaskData toFind, TaskData taskToModify, LocalDateTime oldEndTime,
			String oldCategory, String oldPriority) {
		toFind.setContent(newContent);
		if (newCategory != null)
			toFind.setCategory(newCategory);
		else
			toFind.setCategory(oldCategory);
		if (newPriority != null)
			toFind.setPriority(newPriority);
		else
			toFind.setPriority(oldPriority);
		if (newStartTime != null)
			toFind.setStartDateTime(newStartTime);
		else
			toFind.setStartDateTime(oldEndTime);
		if (newEndTime != null)
			toFind.setEndDateTime(newEndTime);
		else
			toFind.setEndDateTime(oldEndTime);
		toFind = searchTool.findExactTask(toFind, _listTaskToEdit);
		boolean isExisting = toFind != null && toFind != taskToModify;
		return isExisting;
	}

	/**
	 * This method is for modifying the task specified by its index on display
	 * panel with new description
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean modifyIndex(Task task, String content, boolean unredo) {
		String[] a = content.trim().split(" ");
		int index = Integer.parseInt(a[0]);
		content = content.substring(a[0].length()).trim();
		ArrayList<TaskData> displayedList = getDisplayedList();
		int size = displayedList.size();
		if (index < 1 || index > size) {
			messageToUser = MSG_INDEX_OUT_OF_BOUND;
			return false;
		} else {
			TaskData _task = displayedList.get(index - 1);
			Task t = new Task();
			t.setContent(_task.getContent());
			t.setStartDateTime(_task.getStartDateTime());
			t.setEndDateTime(_task.getEndDateTime());
			task.setContent(content);
			return modifyTask(task, t, t.getContent(), unredo);
		}
	}

	/** This method is to mark a task as done or undone**/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean mark(TaskData _task, boolean unredo) {
		boolean isSuccessful = false;
		String content = _task.getContent();
		if (isInteger(content)) {
			return markByIndex(Integer.parseInt(content), unredo);
		}
		if (done) {
			messageToUser = MSG_NOT_ALLOWED_MARK;
			return false;
		}
		HashMap<DateInfo, TaskData> _taskToEdit = taskIdentifier.get(content);
		TaskData task = null;
		LocalDateTime st = _task.getStartDateTime();
		LocalDateTime et = _task.getEndDateTime();

		task = getTaskToMark(_task, unredo, _taskToEdit, st, et);

		if (task != null) {
			if (_taskToEdit.size() == 1)
				taskIdentifier.remove(content);
			else {
				DateInfo d = new DateInfo(task.getStartDateTime(),
						task.getEndDateTime());
				_taskToEdit.remove(d);
			}
			taskList.remove(task);
			if (F2DisplayedList.contains(task)) {
				F2DisplayedList.remove(task);
			}
			String s = task.getStartDateTime() + "" + task.getEndDateTime();

			completedTaskIdentifier.put(s, task);
			completedTask.add(task);
			Task t = toTask(task, true);
			action = new Action(command, t);
			isSuccessful = true;
		} else {
			return isSuccessful;
		}
		try {
			saveData();
			saveCompletedTask();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
			return false;
		}
		return isSuccessful;
	}

	/** This method is to find the task to modify **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	private TaskData getTaskToMark(TaskData _task, boolean unredo,
			HashMap<DateInfo, TaskData> _taskToEdit, LocalDateTime st,
			LocalDateTime et) {
		TaskData task;
		if (unredo || st != null || et != null) {
			DateInfo d = new DateInfo(st, et);
			task = _taskToEdit.get(d);
			if (isSuspendedAction) {
				suspendingAction = null;
				isSuspendedAction = false;
			}
		} else {
			if (isSuspendedAction) {
				DateInfo d = new DateInfo(st, et);
				task = _taskToEdit.get(d);
				suspendingAction = null;
				isSuspendedAction = false;
			} else {
				task = searchTool.findTaskByContentandDate(_task, _taskToEdit);
				if (task.getContent().equals("xxxxxxxxxxxxxxxxxxxx")) {
					if (isSuspendedAction) {
						suspendingAction = null;
						isSuspendedAction = false;
					} else {
						suspendingAction = action;
						isSuspendedAction = true;
					}
					task = null;
				}
			}
		}
		return task;
	}

	/**
	 * This method is for marking a task specified by its index on display panel
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	private boolean markByIndex(int index, boolean unredo) {
		ArrayList<TaskData> displayedList = getDisplayedList();
		int size = displayedList.size();
		if (index < 1 || index > size) {
			messageToUser = MSG_INDEX_OUT_OF_BOUND;
			return false;
		} else {
			TaskData task = displayedList.get(index - 1);
			return mark(task, unredo);
		}

	}

	/** This method is to block a list of slots **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	private boolean block(ArrayList<TaskData> blocks) {
		ArrayList<TaskData> block = new ArrayList<TaskData>();
		for (TaskData _task : blocks) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (_start == null || _end == null) {
				messageToUser = MSG_TIME_SPECIFIED;
				return false;
			}
			block.addAll(block(_task));
		}
		blockSlot.push(block);
		storer.saveTasks(blockedPath, blockedList);
		return true;
	}

	/** This method is to unblock a list of slots **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean unblock(ArrayList<TaskData> blocks) {

		ArrayList<TaskData> unblock = new ArrayList<TaskData>();
		for (TaskData _task : blocks) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (_start == null || _end == null) {
				messageToUser = MSG_TIME_SPECIFIED;
				return false;
			}
			unblock.addAll(unblock(_task));
		}
		unblockSlot.push(unblock);
		storer.saveTasks(blockedPath, blockedList);
		return true;
	}

	/** This method is to block a slot **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private ArrayList<TaskData> block(TaskData slot) {

		LocalDateTime st = slot.getStartDateTime();
		LocalDateTime et = slot.getEndDateTime();
		LocalDateTime start = slot.getStartDateTime();
		LocalDateTime end = slot.getEndDateTime();
		slot.setContent("Blocked slot");
		blockedList.add(slot);
		ArrayList<TaskData> copy = new ArrayList<TaskData>(blockedList);
		for (TaskData _task : copy) {
			if (_task == slot)
				continue;
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (isClash(start, end, _start, _end)
					|| isSequential(start, end, _start, _end)) {
				_start = chooseStart(start, _start);
				_end = chooseEnd(end, _end);
				slot.setStartDateTime(_start);
				slot.setEndDateTime(_end);
				blockedList.remove(_task);
			}
			start = slot.getStartDateTime();
			end = slot.getEndDateTime();
		}
		ArrayList<TaskData> block = new ArrayList<TaskData>();
		block.add(new TaskData("Blocked slot", null, null, st, et));
		return block;
	}

	/** This method is to unblock a slot **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private ArrayList<TaskData> unblock(TaskData task) {
		LocalDateTime start = task.getStartDateTime();
		LocalDateTime end = task.getEndDateTime();
		ArrayList<TaskData> copy = new ArrayList<TaskData>(blockedList);
		ArrayList<TaskData> unblocked = new ArrayList<TaskData>();
		for (TaskData _task : copy) {
			LocalDateTime _start = _task.getStartDateTime();
			LocalDateTime _end = _task.getEndDateTime();
			if (isClash(start, end, _start, _end)) {
				if ((start.isBefore(_start) || start.equals(_start))
						&& (end.isAfter(_end) || end.equals(_end))) {
					blockedList.remove(_task);
					unblocked.add(new TaskData(null, null, null, _start, _end));
					continue;
				}
				if (_start.isBefore(start) && _end.isAfter(end)) {
					_task.setEndDateTime(start);
					blockedList.remove(_task);
					_task.setEndDateTime(start);
					TaskData t = new TaskData();
					t.setStartDateTime(end);
					t.setEndDateTime(_end);
					t.setContent("Blocked slot");
					_task.setContent("Blocked slot");
					blockedList.add(0, t);
					blockedList.add(0, _task);
					unblocked.add(new TaskData(null, null, null, start, end));
					continue;
				}
				if ((start.isBefore(_start) || start.equals(_start)) && end.isBefore(_end)) {
					blockedList.remove(_task);
					_task.setStartDateTime(end);
					blockedList.add(_task);
					unblocked.add(new TaskData(null, null, null, _start, end));
					continue;
				}
				if (_start.isBefore(start) && (_end.isBefore(end) || end.equals(_end))) {
					blockedList.remove(_task);
					_task.setEndDateTime(start);
					blockedList.add(_task);
					unblocked.add(new TaskData(null, null, null, start, _end));
					continue;
				}
			}
		}
		return unblocked;
	}

	private LocalDateTime chooseStart(LocalDateTime start1, LocalDateTime start2) {
		return (start1.isBefore(start2)) ? start1 : start2;
	}

	private LocalDateTime chooseEnd(LocalDateTime end1, LocalDateTime end2) {
		return (end1.isAfter(end2)) ? end1 : end2;
	}

	/** This method checks if two periods of time clash with each other **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	private boolean isClash(LocalDateTime start1, LocalDateTime end1,
			LocalDateTime start2, LocalDateTime end2) {
		if (start1.isEqual(start2) || end1.isEqual(end2))
			return true;
		if (start1.isAfter(start2) && start1.isBefore(end2)
				|| start2.isAfter(start1) && start2.isBefore(end1))
			return true;
		if (start1.isAfter(start2) && end1.isBefore(end2)
				|| start2.isAfter(start1) && end2.isBefore(end1))
			return true;
		return false;
	}

	/** This method checks if two periods of time are sequential **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	private boolean isSequential(LocalDateTime start1, LocalDateTime end1,
			LocalDateTime start2, LocalDateTime end2) {
		return start1.isEqual(end2) || start2.isEqual(end1);
	}

	/** This method is for redoing an action **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean redo() throws IOException, ParseException {
		if (redoList.isEmpty()) {
			messageToUser = MSG_CANNOT_REDO_ANYMORE;
			return false;
		}
		ActionEntry ae = redoList.pop();
		Action done = ae.getAction();
		Task t = ae.getTask();

		actionList.push(ae);
		Command command = done.getCommand();
		Task task = done.getTask();

		TaskData _task = toTaskData(task);
		switch (command) {
		case ADD:
			if (task.isDone()) {
				this.done = true;
			}
			return addTask(_task, true);
		case DELETE:
			if (task.isDone()) {
				this.done = true;
			}
			return deleteTask(_task, true);
		case MODIFY:
			return modifyTask(task, t, true);
		case MARK:
			return mark(_task, true);
		case BLOCK:
			ArrayList<TaskData> blockList = unblockSlot.pop();
			blockSlot.push(blockList);
			return block(blockList);
		case UNBLOCK:
			ArrayList<TaskData> unblockList = blockSlot.pop();
			unblockSlot.push(unblockList);
			return unblock(unblockList);
		default:
			return false;
		}
	}

	/** This method is for undoing an action **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean undo() {
		boolean isSuccessful = false;
		if (actionList.isEmpty()) {
			messageToUser = MSG_CANNOT_UNDO;
			return isSuccessful;
		}
		ActionEntry x = actionList.pop();
		Action done = x.getAction();
		Command command = done.getCommand();
		switch (command) {
		case ADD:
			isSuccessful = undoAdd(done);
			break;
		case DELETE:
			isSuccessful = undoDelete(done);
			break;
		case MODIFY:
			isSuccessful = undoModify(done, x.getTask());
			break;
		case MARK:
			isSuccessful = undoMark(done);
			break;
		case BLOCK:
			isSuccessful = undoBlock(done);
			break;
		case UNBLOCK:
			isSuccessful = undoUnblock(done);
			break;
		default:
			isSuccessful = false;
			break;
		}
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean undoDelete(Action done) {
		if (done.getTask().isDone()) {
			this.done = true;
		}
		boolean isSuccessful = addTask(toTaskData(done.getTask()), true);
		if (isSuccessful)
			redoList.push(new ActionEntry(done, null));
		else
			actionList.push(new ActionEntry(done, null));
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean undoAdd(Action done) {
		if (done.getTask().isDone()) {
			this.done = true;
		}
		boolean isSuccessful = deleteTask(toTaskData(done.getTask()), true);
		if (isSuccessful)
			redoList.push(new ActionEntry(done, null));
		else
			actionList.push(new ActionEntry(done, null));
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean undoModify(Action done, Task t) {
		boolean isSuccessful = modifyTask(done.getTask(), t, true);
		if (isSuccessful)
			redoList.push(entry);
		else
			actionList.push(entry);
		return isSuccessful;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean undoMark(Action done) {
		Task task = done.getTask();
		boolean isSuccessful = false;
		String s = task.getStartDateTime() + "" + task.getEndDateTime();
		TaskData _task = completedTaskIdentifier.get(s);
		try {
			completedTask.remove(_task);
			isSuccessful = addTask(_task, true);
			saveCompletedTask();
		} catch (IOException e) {
			isSuccessful = false;
		}
		if (isSuccessful) {
			redoList.push(new ActionEntry(done, null));
		} else {
			actionList.push(new ActionEntry(done, null));
		}
		return isSuccessful;
	}

	private boolean undoBlock(Action done) {
		boolean isSuccessful = false;
		ArrayList<TaskData> blockList = blockSlot.pop();
		isSuccessful = unblock(blockList);
		unblockSlot.push(blockList);
		if (isSuccessful) {
			redoList.push(new ActionEntry(done, null));
		} else {
			actionList.push(new ActionEntry(done, null));
		}
		return isSuccessful;
	}

	private boolean undoUnblock(Action done) {
		boolean isSuccessful = false;
		ArrayList<TaskData> blockList = unblockSlot.pop();
		isSuccessful = block(blockList);
		blockSlot.push(blockList);
		if (isSuccessful) {
			redoList.push(new ActionEntry(done, null));
		} else {
			actionList.push(new ActionEntry(done, null));
		}
		return isSuccessful;
	}

	/**
	 * This method is to search for a task or a block slot, return in
	 * searchResult
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	private boolean search(Task task) throws IOException, ParseException {
		searchResult = new ArrayList<TaskData>();
		String content = task.getContent();
		if (content != null
				&& !content.isEmpty()
				&& (content.startsWith("block") || content
						.startsWith("blocked"))) {
			searchResult = blockedList;
		} else {
			if (task.isDone() == null || !task.isDone()) {
				searchResult = searchTool.search(taskList, task);
				done = false;
			} else {
				searchResult = searchTool.search(completedTask, task);
				done = true;
			}
		}
		if (searchResult != null) {
			return true;
		}

		overdueRow = 0;
		return false;
	}

	/** This method is to exit, data is saved and jframe is minimised to tray **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private boolean exit() {
		// store when exit
		try {
			saveData();
			saveCompletedTask();
		} catch (IOException e) {
			messageToUser = MSG_ERROR_WHILE_SAVING_DATA;
		}
		return true;
		// System.exit(0);
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	public void saveData() throws IOException {
		storer.saveTasks(taskFilePath, taskList);
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private void saveCompletedTask() throws IOException {
		storer.saveTasks(completedTaskFilePath, completedTask);
	}

	/** This method returns tasks to come **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	public ArrayList<TaskData> getTaskToCome() {
		LocalDateTime now = LocalDateTime.now();
		int dateToday = now.getDayOfMonth();
		int monthToday = now.getMonthValue();
		int yearToday = now.getYear();
		LocalDateTime today = LocalDateTime.of(yearToday, monthToday,
				dateToday, 0, 0, 0).minusSeconds(1);
		LocalDateTime tomorrow = today.plusSeconds(172801);
		today = now;
		ArrayList<TaskData> taskToCome = new ArrayList<TaskData>();
		for (TaskData _task : taskList) {
			LocalDateTime st = _task.getStartDateTime();
			LocalDateTime et = _task.getEndDateTime();
			if (st != null && st.isAfter(today) && st.isBefore(tomorrow)) {
				taskToCome.add(_task);
			} else if (et != null && et.isAfter(today) && et.isBefore(tomorrow)) {
				taskToCome.add(_task);
			} else if (st != null && et != null
					&& isClash(st, et, today, tomorrow)) {
				taskToCome.add(_task);
			}
		}
		return taskToCome;
	}

	/** This methods answers UI, checks if a date has task **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	public boolean hasTask(String date) throws IOException, ParseException {
		Task testTask = parser.getAction(date).getTask();
		LocalDateTime time = testTask.getStartDateTime();
		int dayOfMonth = time.getDayOfMonth();
		int month = time.getMonthValue();
		int year = time.getYear();
		LocalDateTime startTime = LocalDateTime.of(year, month, dayOfMonth, 0,
				0, 0).minusSeconds(1);
		LocalDateTime endTime = LocalDateTime.of(year, month, dayOfMonth, 23,
				59, 59).plusSeconds(1);
		ArrayList<TaskData> task = new ArrayList<TaskData>();
		for (TaskData _task : taskList) {
			LocalDateTime st = _task.getStartDateTime();
			LocalDateTime et = _task.getEndDateTime();
			if (st != null && st.isAfter(startTime) && st.isBefore(endTime)) {
				task.add(_task);
			} else if (et != null && et.isAfter(startTime)
					&& et.isBefore(endTime)) {
				task.add(_task);
			} else if (st != null && et != null
					&& isClash(st, et, startTime, endTime)) {
				task.add(_task);
			}
		}
		return !task.isEmpty();
	}

	/** This method returns overdue task to UI **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	public ArrayList<TaskData> getOverdue() {
		ArrayList<TaskData> overdue = new ArrayList<TaskData>();
		LocalDateTime now = LocalDateTime.now();
		Collections.sort(taskList);
		for (TaskData _task : taskList) {
			LocalDateTime endTime = _task.getEndDateTime();
			if (endTime != null && endTime.isBefore(now)) {
				overdue.add(_task);
			}
		}
		return overdue;
	}

	/** This methods return all categories to UI **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	public String getCategory() {
		ArrayList<String> category = new ArrayList<String>();
		for (TaskData _task : taskList) {
			String cat = _task.getCategory();
			if (cat != null && !category.contains(cat))
				category.add(cat);
		}
		String res = "";
		for (String cat : category) {
			res += cat + "\n";
		}
		return res;
	}

	/** This methods return data of recently added tasks to UI **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	public String getData(String s) throws IOException, ParseException {
		currentDisplayList = 2;
		return dataToShow();
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private String dataToShow() throws IOException, ParseException {
		return showToUser(F2DisplayedList);
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private String showToUser(ArrayList<TaskData> taskToShow) {
		String text = "";
		SimpleDateFormat formater = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm");
		SimpleDateFormat f = new SimpleDateFormat("EEE, d MMM yyyy HH:mm");
		int i = 1;
		for (TaskData t : taskToShow) {
			text += i + ": ";
			text += t.getContent();
			if (t.getPriority() != null)
				text += "\n " + t.getPriority() + " priority ";
			if (t.getCategory() != null)
				text += "\n #" + t.getCategory() + " ";
			if (t.getStartDateTime() != null) {
				Date d;
				try {
					d = formater.parse(t.getStartDateTime() + "");
					String s = f.format(d);
					text += "\n From: " + s;
				} catch (java.text.ParseException e) {
				}
			}
			if (t.getEndDateTime() != null) {
				Date d;
				try {
					d = formater.parse(t.getEndDateTime() + "");
					String s = f.format(d);
					text += "\n To : " + s;
				} catch (java.text.ParseException e) {
				}
			}
			text += "\n";
			i++;
		}
		return text;
	}

	/* clear all data */
	//author A0112066U
	public void clear() throws IOException {
		taskList.clear();
		saveData();
	}

	/** This method translates a Task to TaskData for storage **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private TaskData toTaskData(Task task) {
		String content = task.getContent();
		LocalDateTime startTime = task.getStartDateTime();
		LocalDateTime endTime = task.getEndDateTime();
		String category = task.getCategory();
		String priority = task.getPriority();
		return new TaskData(content, category, priority, startTime, endTime);
	}

	/** This method translates a TaskData to Task **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private Task toTask(TaskData task, boolean done) {
		Task t = new Task();
		t.setContent(task.getContent());
		t.setCategory(task.getCategory());
		t.setStartDateTime(task.getStartDateTime());
		t.setEndDateTime(task.getEndDateTime());
		t.setPriority(task.getPriority());
		t.setDone(done);
		return t;
	}

	/** This method is to check whether a string provided is an integer **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private static boolean isInteger(String index) {
		try {
			Integer.parseInt(index);
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
	}

	/** This method returns to UI the list of tasks it requires **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */


	public ArrayList<DisplayedEntry> getRequiredTask(String userCommand) {
		Command cmd = null;
		if (userCommand != null && !userCommand.isEmpty()) {
			cmd = parser.getAction(userCommand).getCommand();
		}
		if (cmd != null && cmd.equals(Command.SEARCH)) {

			F3DisplayedList = new ArrayList<TaskData>(searchResult);
			overdueRow = 0;
		}
		if (cmd == null || cmd.equals("") || cmd.equals(Command.ADD)
				|| cmd.equals(Command.DELETE) || cmd.equals(Command.MODIFY)
				|| cmd.equals(Command.MARK) || cmd.equals(Command.UNDO)
				|| cmd.equals(Command.REDO)) {
			F3DisplayedList = new ArrayList<TaskData>();
			ArrayList<TaskData> overdue = getOverdue();
			overdueRow = overdue.size();
			ArrayList<TaskData> tasksToCome = getTaskToCome();
			F3DisplayedList.addAll(overdue);
			F3DisplayedList.addAll(tasksToCome);
			for (TaskData t : taskList) {
				if (!overdue.contains(t) && !tasksToCome.contains(t))
					F3DisplayedList.add(t);
			}
			done = false;
		}
		currentDisplayList = 3;
		ArrayList<DisplayedEntry> tobeShown = new ArrayList<DisplayedEntry>();
		if (F3DisplayedList != null) {
			for (TaskData t : F3DisplayedList) {
				tobeShown.add(toDisplayedEntry(t));
			}
		}
		return tobeShown;
	}

	public int getOverdueRow() {
		return overdueRow;
	}

	public String getBlock() {
		String result = "";
		for (TaskData block : blockedList) {
			DisplayedEntry b = new DisplayedEntry(block);
			try {
				result += b.getStartDateTime() + " - " + b.getEndDateTime();
				result += "\n";
			} catch (java.text.ParseException e) {
			}
		}
		return result;
	}
	/** This method is to determined what list of tasks is being displayed **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private ArrayList<TaskData> getDisplayedList() {
		if (currentDisplayList == 2) {
			return F2DisplayedList;
		} else if (currentDisplayList == 3) {
			return F3DisplayedList;
		}
		return null;
	}

	/**
	 * This method translates a TaskData to a DisplayedEntry for displaying in
	 * UI
	 **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java
	 */

	private DisplayedEntry toDisplayedEntry(TaskData task) {
		return new DisplayedEntry(task);
	}
}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\Logic.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\OtherDataTypes.java
	 */

 */

import java.time.LocalDateTime;

import parser.Action;
import parser.Task;

class DateInfo {
	private LocalDateTime start, end;

	public DateInfo(LocalDateTime _start, LocalDateTime _end) {
		if (_start == null) {
			this.start = LocalDateTime.MIN;
		} else {
			this.start = _start;
		}
		if (_end == null) {
			this.end = LocalDateTime.MAX;
		} else {
			this.end = _end;
		}
	}

	public LocalDateTime getStartDateTime() {
		return start;
	}

	public LocalDateTime getEndDateTime() {
		return end;
	}

	@Override
	public boolean equals(Object t) {
		if (t instanceof DateInfo) {
			DateInfo time = (DateInfo) t;
			return this.start.equals(time.start) && this.end.equals(time.end);
		} else
			return false;
	}

	@Override
	public int hashCode() {
		String s = start + "" + end;
		return s.hashCode();

	}
}

class ActionEntry {
	private Action action;
	private Task task;

	public ActionEntry(Action action, Task task) {
		this.action = action;
		this.task = task;
	}

	public Action getAction() {
		return action;
	}

	public Task getTask() {
		return task;
	}
}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\OtherDataTypes.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java
	 */

	public TaskData findTaskByContentandDate(TaskData task,
			HashMap<DateInfo, TaskData> toFindList) {

		TaskData taskFound = null;
		LocalDateTime st = task.getStartDateTime();
		LocalDateTime et = task.getEndDateTime();

		if (toFindList.size() == 1) {
			for (TaskData _task : toFindList.values()) {
				taskFound = _task;
			}

			LocalDateTime s = taskFound.getStartDateTime();
			LocalDateTime e = taskFound.getEndDateTime();
			if (st != null && !st.equals(s))
				taskFound = null;
			if (et != null && !et.equals(e))
				taskFound = null;

		} else if (toFindList.size() > 1) {
			if (st == null && et == null) {
				taskFound = new TaskData();
				taskFound.setContent(message);
				return taskFound;
			}
			DateInfo d = new DateInfo(st, et);
			if (toFindList.containsKey(d)) {
				taskFound = toFindList.get(d);
			}

		}
		return taskFound;
	}

	/** This method finds the task with exact info (content and time) **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java
	 */

	public TaskData findExactTask(TaskData task,
			HashMap<DateInfo, TaskData> toFindList) {
		TaskData taskFound = null;
		LocalDateTime st = task.getStartDateTime();
		LocalDateTime et = task.getEndDateTime();
		DateInfo d = new DateInfo(st, et);
		if (toFindList.containsKey(d)) {
			taskFound = toFindList.get(d);
		}
		if (taskFound == null)
			return null;
		if (!hasSameDateTime(task, taskFound))
			return null;
		return taskFound;
	}

	private boolean hasSameDateTime(TaskData t1, TaskData t2) {
		DateInfo d1 = new DateInfo(t1.getStartDateTime(), t1.getEndDateTime());
		DateInfo d2 = new DateInfo(t2.getStartDateTime(), t2.getEndDateTime());
		return d1.hashCode() == d2.hashCode();
	}

	/** This method search for a task bby given info **/
	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java
	 */

	public ArrayList<TaskData> search(ArrayList<TaskData> taskList, Task task)
			throws IOException, ParseException {
		if (taskList.isEmpty()) {
			return new ArrayList<TaskData>();
		}

		String content = task.getContent();
		String[] words;
		if (content != null)
			words = content.split(" "); // keyword for searching
		else
			words = new String[] { "" };
		LocalDateTime startTime = task.getStartDateTime();
		LocalDateTime endTime = task.getEndDateTime(); // search in between
														// startTime and endTime
		String category = task.getCategory(); // search in category
		String priority = task.getPriority(); // search by priority

		ArrayList<TaskData> searchResult = new ArrayList<TaskData>();
		searchResult = filterByTime(taskList, startTime, endTime);
		if (category != null)
			searchResult = filterByCategory(searchResult, category.split(" "));
		if (priority != null)
			searchResult = filterByPriority(searchResult, priority);
		searchResult = filterByKeywords(searchResult, words);

		return searchResult;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java
	 */

	private ArrayList<TaskData> filterByTime(ArrayList<TaskData> taskList,
			LocalDateTime startTime, LocalDateTime endTime) {
		ArrayList<TaskData> searchResult = new ArrayList<TaskData>();
		if (startTime != null && endTime != null) {
			startTime = startTime.minusSeconds(1);
			endTime = endTime.plusSeconds(1);
			for (TaskData _task : taskList) {
				LocalDateTime st = _task.getStartDateTime();
				LocalDateTime et = _task.getEndDateTime();
				if (st != null && st.isAfter(startTime) && st.isBefore(endTime)) {
					searchResult.add(_task);
				} else if (et != null && et.isAfter(startTime)
						&& et.isBefore(endTime)) {
					searchResult.add(_task);
				}
			}

		} else if (startTime != null) {
			startTime = startTime.minusSeconds(1);
			for (TaskData _task : taskList) {
				LocalDateTime st = _task.getStartDateTime();
				if (st != null && st.isAfter(startTime)) {
					searchResult.add(_task);
				}
			}

		} else {
			searchResult = taskList;
		}
		return searchResult;
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java
	 */

	private ArrayList<TaskData> filterByCategory(ArrayList<TaskData> taskList,
			String[] _category) {
		ArrayList<TaskData> searchResult = new ArrayList<TaskData>();
		List<String> _cat = Arrays.asList(_category);
		if (_category.length == 0)
			return taskList;
		else {
			for (TaskData t : taskList) {
				if (_cat.contains(t.getCategory()))
					searchResult.add(t);
			}
			return searchResult;
		}
	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java
	 */

	private ArrayList<TaskData> filterByPriority(ArrayList<TaskData> taskList,
			String _priority) {
		ArrayList<TaskData> searchResult = new ArrayList<TaskData>();

		for (TaskData t : taskList) {
			if (t.getPriority().contains(_priority))
				searchResult.add(t);
		}
		return searchResult;

	}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java
	 */

	private ArrayList<TaskData> filterByKeywords(ArrayList<TaskData> taskList,
			String[] _words) {
		ArrayList<TaskData> searchResult = new ArrayList<TaskData>();
		for (String w : _words) {
			w = w.toLowerCase();
		}
		for (TaskData t : taskList) {
			boolean isContained = true;
			for (String word : _words) {
				if (!t.getContent().toLowerCase().contains(word)) {
					isContained = false;
					break;
				}
			}
			if (isContained)
				searchResult.add(t);
		}
		return searchResult;
	}

}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\src\logic\SearchTool.java





	/**
	 * origin: C:\Users\Kamui\git\main\FlexiPlanner\unit-tests\logic\LogicTest.java
	 */

 */

import static org.junit.Assert.*;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.time.LocalDateTime;

import org.json.simple.parser.ParseException;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import commons.TaskData;

public class LogicTest {

	CopyLogic logic;

	@Before
	public void initialise() {
		try {
			logic = new CopyLogic();
			logic.clear();
		} catch (FileNotFoundException e) {
		} catch (IOException e) {
		} catch (ParseException e) {
		}
	}

	// normal case + undo + redo
	@Test
	public void testAddNomal() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);

			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("funny");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 11, 14, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 11, 16, 00));
			task.setPriority("normal");
			assertTrue(logic.taskList.contains(task));

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(!logic.taskList.contains(task));

			command = "redo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(logic.taskList.contains(task));

		} catch (IOException | ParseException e) {
		}
	}

	@Test
	public void testAddFloating() {
		try {
			String command = "meet Jim";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("none");
			task.setPriority("normal");
			assertTrue(logic.taskList.contains(task));

		} catch (IOException | ParseException e) {
		}
	}

	// empty input case + undo
	@Test
	public void testAddEmpty() {
		try {
			String command = "";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", s, CopyLogic.MSG_ERROR
					+ CopyLogic.MSG_EMPTY_INPUT);

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ERROR
					+ CopyLogic.MSG_CANNOT_UNDO, s);

		} catch (IOException | ParseException e) {
		}
	}

	// add an existing task
	@Test
	public void testAddExistingTask() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "meet Jim from 11/11 2pm 4pm";
			logic.executeInputCommand(command);
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ERROR
					+ CopyLogic.MSG_EXISTING_TASK, s);

		} catch (IOException | ParseException e) {
		}
	}

	// modify normal case + undo + redo
	@Test
	public void testModifyNormal() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "modify meet Jim from 11/11 3pm 4pm #project important";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("project");
			task.setPriority("high");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 11, 15, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 11, 16, 00));
			assertTrue(logic.taskList.contains(task));

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			task.setCategory("funny");
			task.setPriority("normal");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 11, 14, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 11, 16, 00));
			assertTrue(logic.taskList.contains(task));

			command = "redo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			task.setCategory("project");
			task.setPriority("high");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 11, 15, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 11, 16, 00));
			assertTrue(logic.taskList.contains(task));
		} catch (IOException | ParseException e) {
		}
	}

	// modify one of two tasks of same content + undo + redo
	@Test
	public void testModifyTasksOfSameContent() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "add meet Jim from 12/11 3pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "modify meet Jim from 13/11 3pm 4pm #project important";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ASK_FOR_TIME, s);
			command = "11/11 2pm 4pm";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("project");
			task.setPriority("high");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 13, 15, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 13, 16, 00));
			assertTrue(logic.taskList.contains(task));

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			task.setCategory("funny");
			task.setPriority("normal");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 11, 14, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 11, 16, 00));
			assertTrue(logic.taskList.contains(task));

			command = "redo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			task.setCategory("project");
			task.setPriority("high");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 13, 15, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 13, 16, 00));
			assertTrue(logic.taskList.contains(task));
		} catch (IOException | ParseException e) {
		}
	}

	// modify non existen task
	@Test
	public void testModifyNonExistTask() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "modify meet Anna from 11/11 3pm 4pm #project important";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ERROR
					+ CopyLogic.MSG_NO_TASK_FOUND, s);
		} catch (IOException | ParseException e) {
		}
	}

	// delete normal case + undo + redo
	@Test
	public void testDeleteNormal() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "delete meet Jim";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(logic.taskList.isEmpty());

			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("funny");
			task.setPriority("normal");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 11, 14, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 11, 16, 00));

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(logic.taskList.contains(task));

			command = "redo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(!logic.taskList.contains(task));
		} catch (IOException | ParseException e) {
		}
	}

	// delete non existen task
	@Test
	public void testDeleteNonExistTask() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "delete Jim";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ERROR
					+ CopyLogic.MSG_NO_TASK_FOUND, s);
		} catch (IOException | ParseException e) {
		}
	}

	// delete one of two tasks of same content + undo + redo
	@Test
	public void testDeleteDuplicateTask() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "add meet Jim from 12/11 3pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "delete meet Jim";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ASK_FOR_TIME, s);
			command = "12/11 3pm 4pm";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);

			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("funny");
			task.setPriority("normal");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 12, 15, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 12, 16, 00));
			assertTrue(!logic.taskList.contains(task));
			assertTrue(logic.taskList.size() == 1);

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(logic.taskList.contains(task));

			command = "redo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(!logic.taskList.contains(task));
		} catch (IOException | ParseException e) {
		}
	}

	// mark normal
	@Test
	public void testMarkNormal() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "mark meet Jim";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);

			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("funny");
			task.setPriority("normal");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 11, 14, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 11, 16, 00));
			assertTrue(logic.taskList.isEmpty());
			assertTrue(logic.completedTask.contains(task));

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(logic.taskList.contains(task));
			assertTrue(!logic.completedTask.contains(task));

			command = "redo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(!logic.taskList.contains(task));
			assertTrue(logic.completedTask.contains(task));
		} catch (IOException | ParseException e) {
		}
	}

	// mark one of two task of same content as done
	@Test
	public void testMarkTaskOfSameContent() {
		try {
			String command = "add meet Jim from 11/11 2pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "add meet Jim from 12/11 3pm 4pm #funny";
			logic.executeInputCommand(command);
			command = "mark meet Jim";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ASK_FOR_TIME, s);
			command = "12/11 3pm 4pm";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);

			TaskData task = new TaskData();
			task.setContent("meet Jim");
			task.setCategory("funny");
			task.setPriority("normal");
			task.setStartDateTime(LocalDateTime.of(2014, 11, 12, 15, 00));
			task.setEndDateTime(LocalDateTime.of(2014, 11, 12, 16, 00));
			assertTrue(!logic.taskList.contains(task));
			assertTrue(logic.completedTask.contains(task));

			command = "undo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(logic.taskList.contains(task));
			assertTrue(!logic.completedTask.contains(task));

			command = "redo";
			s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			assertTrue(!logic.taskList.contains(task));
			assertTrue(logic.completedTask.contains(task));
		} catch (IOException | ParseException e) {
		}
	}

	@Test
	public void testBlockThenAdd() {
		try {
			String command = "block 11/11 1pm 5pm";
			logic.executeInputCommand(command);
			command = "add meet Jim from 11/11 3pm 4pm #funny";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_ERROR + CopyLogic.MSG_CLASHES, s);
		} catch (IOException | ParseException e) {
		}
	}

	public void testUnBlock() {
		try {
			String command = "block 11/11 1pm 5pm";
			logic.executeInputCommand(command);
			command = "unblock 11/11 2pm 3pm";
			String s = logic.executeInputCommand(command);
			assertEquals("fail", CopyLogic.MSG_SUCCESSFUL, s);
			
			TaskData block = new TaskData();
			block.setContent("Blocked slot");
			block.setStartDateTime(LocalDateTime.of(2014, 11, 11, 13, 00));
			block.setEndDateTime(LocalDateTime.of(2014, 11, 11, 14, 00));
			assertTrue(logic.blockedList.contains(block));

			TaskData block1 = new TaskData();
			block1.setContent("Blocked slot");
			block1.setStartDateTime(LocalDateTime.of(2014, 11, 11, 13, 00));
			block1.setEndDateTime(LocalDateTime.of(2014, 11, 11, 14, 00));
			assertTrue(logic.blockedList.contains(block1));
			
			TaskData block2 = new TaskData();
			block2.setContent("Blocked slot");
			block2.setStartDateTime(LocalDateTime.of(2014, 11, 11, 15, 00));
			block2.setEndDateTime(LocalDateTime.of(2014, 11, 11, 17, 00));
			assertTrue(logic.blockedList.contains(block2));

			// undo
			command = "undo";
			s = logic.executeInputCommand(command);
			assertTrue(logic.blockedList.contains(block));
			
			command = "undo";
			s = logic.executeInputCommand(command);
			assertTrue(logic.blockedList.contains(block1));
			assertTrue(logic.blockedList.contains(block2));
			
		} catch (IOException | ParseException e) {
		}
	}
	
	@Test
	public void testSearch() {
		try {
			logic.executeInputCommand("lunch with John 11/11 1pm");
			logic.executeInputCommand("do CS2101 assignment 11/11 8pm 10pm #study");
			logic.executeInputCommand("meet Jim #project very importent 12/11 10am");
			
			logic.executeInputCommand("search assignment"); //search existent
			TaskData t = new TaskData();
			t.setCategory("study");
			t.setContent("do CS2101 assignment");
			t.setPriority("normal");
			t.setStartDateTime(LocalDateTime.of(2014, 11, 11, 20, 00));
			t.setEndDateTime(LocalDateTime.of(2014, 11, 11, 22, 00));
			assertTrue(logic.searchResult.contains(t));
			
			assertTrue(logic.searchResult.contains(t));

		} catch (IOException | ParseException e) {
			
		}
		
	}

	@After
	public void clear() {
		try {
			logic.clear();
		} catch (IOException e) {

		}
	}
}

	// End of segment: C:\Users\Kamui\git\main\FlexiPlanner\unit-tests\logic\LogicTest.java





